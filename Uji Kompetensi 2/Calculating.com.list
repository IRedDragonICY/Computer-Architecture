EMU8086 GENERATED LISTING. MACHINE CODE <- SOURCE.
 
Calculating.com -- emu8086 assembler version: 4.00-Beta-17  
 
[ 20/06/2023  --  09:15:59 ] 
 
===================================================================================================
[LINE]     LOC: MACHINE CODE                          SOURCE
===================================================================================================
 
[   1]        :                                       name "Uji Kompetensi 2 - Oleh Mohammad Farid Hendianto 2200018401"
[   2]        :                                       
[   3]        :                                       ; this macro prints a char in AL and advances
[   4]        :                                       ; the current cursor position:
[   5]        :                                       PUTC    MACRO   char
[   6]        :                                       PUSH    AX
[   7]        :                                       MOV     AL, char
[   8]        :                                       MOV     AH, 0Eh
[   9]        :                                       INT     10h
[  10]        :                                       POP     AX
[  11]        :                                       ENDM
[  12]        :                                       ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
[  13]        :                                       
[  14]        :                                       precision=30   ; max digits after the dot.
[  15]        :                                       
[  16]        :                                       org 100h
[  17]        :                                       
[  18]    0100: E9 6D 01                              jmp start
[  19]        :                                       
[  20]        :                                       ; define variables:
[  21]    0103: 46 69 74 75 72 3A 0D 0A               msg0 db "Fitur:",0Dh,0Ah
[  22]    010B: 2B 20 42 69 73 61 20 6D 65 6E 67 67   db "+ Bisa menggunakan bilangan bulat positif maupun negatif:",0Dh,0Ah
                75 6E 61 6B 61 6E 20 62 69 6C 61 6E 
                67 61 6E 20 62 75 6C 61 74 20 70 6F 
                73 69 74 69 66 20 6D 61 75 70 75 6E 
                20 6E 65 67 61 74 69 66 3A 0D 0A    
[  23]    0146: 2B 20 48 61 73 69 6C 20 62 69 73 61   db "+ Hasil bisa berupa floating number:",0Dh,0Ah
                20 62 65 72 75 70 61 20 66 6C 6F 61 
                74 69 6E 67 20 6E 75 6D 62 65 72 3A 
                0D 0A                               
[  24]    016C: 50 65 6D 62 61 74 61 73 61 6E 3A 0D   db "Pembatasan:",0Dh,0Ah
                0A                                  
[  25]    0179: 2D 20 4E 69 6C 61 69 20 70 61 64 61   db "- Nilai pada var A,B,C,D,E tidak bisa mengandung floating number",0Dh,0Ah,0Dh,0Ah
                20 76 61 72 20 41 2C 42 2C 43 2C 44 
                2C 45 20 74 69 64 61 6B 20 62 69 73 
                61 20 6D 65 6E 67 61 6E 64 75 6E 67 
                20 66 6C 6F 61 74 69 6E 67 20 6E 75 
                6D 62 65 72 0D 0A 0D 0A             
[  26]    01BD: 59 20 3D 20 28 41 20 78 20 42 20 2B   db "Y = (A x B + C) / ( D x E)",0Dh,0Ah,'$'
                20 43 29 20 2F 20 28 20 44 20 78 20 
                45 29 0D 0A 24                      
[  27]    01DA: 0D 0A 4D 61 6B 61 20 6E 69 6C 61 69   msg1 db  0dh,0ah , 'Maka nilai Y =  $'
                20 59 20 3D 20 20 24                
[  28]    01ED: 0D 0A 41 72 69 67 61 74 6F 75 20 4E   msg2 db  0dh,0ah ,'Arigatou Nee OwO ~ ', 0Dh,0Ah, '$'
                65 65 20 4F 77 4F 20 7E 20 0D 0A 24 
                                                    
[  29]        :                                       
[  30]        :                                       ; Varible on Registers
[  31]    0205: 00 00                                 A dw ?
[  32]    0207: 00 00                                 B dw ?
[  33]    0209: 00 00                                 C dw ?
[  34]    020B: 00 00                                 D dw ?
[  35]    020D: 00 00                                 E dw ?
[  36]        :                                       
[  37]    020F: 4D 61 73 75 6B 6B 61 6E 20 41 3A 20   string_input_A   DB 'Masukkan A : $'
                24                                  
[  38]    021C: 0D 0A 4D 61 73 75 6B 6B 61 6E 20 42   string_input_B   DB 13,10,'Masukkan B : $'
                3A 20 24                            
[  39]    022B: 0D 0A 4D 61 73 75 6B 6B 61 6E 20 43   string_input_C   DB 13,10,'Masukkan C : $'
                3A 20 24                            
[  40]    023A: 0D 0A 4D 61 73 75 6B 6B 61 6E 20 44   string_input_D   DB 13,10,'Masukkan D : $'
                3A 20 24                            
[  41]    0249: 0D 0A 4D 61 73 75 6B 6B 61 6E 20 45   string_input_E   DB 13,10,'Masukkan E : $'
                3A 20 24                            
[  42]    0258: 0D 0A 59 3D 24                        string_res       DB 13,10,'Y=$'
[  43]    025D: 55 6E 64 65 66 69 6E 65 64 24         sring_undefined  DB 'Undefined$'
[  44]        :                                       ; Temporary Variables;
[  45]    0267: 00 00                                 TEMP dw ?
[  46]    0269: 00 00                                 TEMP2 dw ?
[  47]    026B: 0A 00                                 ten             dw      10      ; used as multiplier.
[  48]    026D: 04 00                                 four            dw      4       ; used as divider.
[  49]    026F: 00                                    make_minus      db      ?       ; used as a flag in procedures.
[  50]        :                                       
[  51]        :                                       
[  52]    0270:                                       start:
[  53]        :                                       
[  54]    0270: BA 03 01                              mov dx, offset msg0
[  55]    0273: B4 09                                 mov ah, 9
[  56]    0275: CD 21                                 int 21h
[  57]        :                                       
[  58]        :                                       ; store A number:
[  59]    0277: BA 0F 02                              lea dx, string_input_A
[  60]    027A: B4 09                                 mov ah, 09h    ; output string at ds:dx
[  61]    027C: CD 21                                 int 21h
[  62]        :                                       
[  63]        :                                       ; get the multi-digit signed number
[  64]        :                                       ; from the keyboard, and store
[  65]        :                                       ; the result in cx register:
[  66]    027E: E8 FC 00                              call scan_num
[  67]    0281: 89 0E 05 02                           mov A,cx
[  68]        :                                       
[  69]        :                                       ; store B number:
[  70]    0285: BA 1C 02                              lea dx, string_input_B
[  71]    0288: B4 09                                 mov ah, 09h
[  72]    028A: CD 21                                 int 21h
[  73]    028C: E8 EE 00                              call scan_num
[  74]    028F: 89 0E 07 02                           mov B,cx
[  75]        :                                       
[  76]        :                                       ; store C number:
[  77]    0293: BA 2B 02                              lea dx, string_input_C
[  78]    0296: B4 09                                 mov ah, 09h
[  79]    0298: CD 21                                 int 21h
[  80]    029A: E8 E0 00                              call scan_num
[  81]    029D: 89 0E 09 02                           mov C,cx
[  82]        :                                       
[  83]        :                                       ; store D number:
[  84]    02A1: BA 3A 02                              lea dx, string_input_D
[  85]    02A4: B4 09                                 mov ah, 09h
[  86]    02A6: CD 21                                 int 21h
[  87]    02A8: E8 D2 00                              call scan_num
[  88]    02AB: 89 0E 0B 02                           mov D,cx
[  89]        :                                       
[  90]        :                                       ; store E number:
[  91]    02AF: BA 49 02                              lea dx, string_input_E
[  92]    02B2: B4 09                                 mov ah, 09h
[  93]    02B4: CD 21                                 int 21h
[  94]    02B6: E8 C4 00                              call scan_num
[  95]    02B9: 89 0E 0D 02                           mov E,cx
[  96]        :                                       
[  97]        :                                       
[  98]        :                                       ; Result step
[  99]        :                                       
[ 100]    02BD: B4 09                                 mov ah,09h
[ 101]    02BF: BA 58 02                              mov dx,OFFSET string_res
[ 102]    02C2: CD 21                                 int 21h
[ 103]        :                                       ; print (
[ 104]    02C4: B4 02                                 mov ah, 02h
[ 105]    02C6: B2 28                                 mov dl, '('
[ 106]    02C8: CD 21                                 int 21h
[ 107]        :                                       
[ 108]        :                                       ; print var A
[ 109]    02CA: A1 05 02                              mov ax,A
[ 110]    02CD: E8 D3 01                              call print_num
[ 111]        :                                       
[ 112]        :                                       ; print x
[ 113]    02D0: B4 02                                 mov ah, 02h
[ 114]    02D2: B2 78                                 mov dl, 'x'
[ 115]    02D4: CD 21                                 int 21h
[ 116]        :                                       
[ 117]        :                                       ; print var B
[ 118]    02D6: A1 07 02                              mov ax,B
[ 119]    02D9: E8 C7 01                              call print_num
[ 120]        :                                       
[ 121]        :                                       ; print +
[ 122]    02DC: B4 02                                 mov ah, 02h
[ 123]    02DE: B2 2B                                 mov dl, '+'
[ 124]    02E0: CD 21                                 int 21h
[ 125]        :                                       
[ 126]        :                                       ; print var C
[ 127]    02E2: A1 09 02                              mov ax,C
[ 128]    02E5: E8 BB 01                              call print_num
[ 129]        :                                       
[ 130]        :                                       ; print )
[ 131]    02E8: B4 02                                 mov ah, 02h
[ 132]    02EA: B2 29                                 mov dl, ')'
[ 133]    02EC: CD 21                                 int 21h
[ 134]        :                                       
[ 135]        :                                       ; print /
[ 136]    02EE: B4 02                                 mov ah, 02h
[ 137]    02F0: B2 2F                                 mov dl, '/'
[ 138]    02F2: CD 21                                 int 21h
[ 139]        :                                       
[ 140]        :                                       ; print (
[ 141]    02F4: B4 02                                 mov ah, 02h
[ 142]    02F6: B2 28                                 mov dl, '('
[ 143]    02F8: CD 21                                 int 21h
[ 144]        :                                       
[ 145]        :                                       ; print var D
[ 146]    02FA: A1 0B 02                              mov ax,D
[ 147]    02FD: E8 A3 01                              call print_num
[ 148]        :                                       
[ 149]        :                                       ; print x
[ 150]    0300: B4 02                                 mov ah, 02h
[ 151]    0302: B2 78                                 mov dl, 'x'
[ 152]    0304: CD 21                                 int 21h
[ 153]        :                                       
[ 154]        :                                       ; print var E
[ 155]    0306: A1 0D 02                              mov ax,E
[ 156]    0309: E8 97 01                              call print_num
[ 157]        :                                       
[ 158]        :                                       ; print )
[ 159]    030C: B4 02                                 mov ah, 02h
[ 160]    030E: B2 29                                 mov dl, ')'
[ 161]    0310: CD 21                                 int 21h
[ 162]        :                                       
[ 163]        :                                       
[ 164]        :                                       ; new line:
[ 165]    0312: 50 B0 0D B4 0E CD 10 58               putc 0Dh
[ 166]    031A: 50 B0 0A B4 0E CD 10 58               putc 0Ah
[ 167]        :                                       
[ 168]        :                                       
[ 169]    0322: BA DA 01                              lea dx, msg1
[ 170]    0325: B4 09                                 mov ah, 09h      ; output string at ds:dx
[ 171]    0327: CD 21                                 int 21h
[ 172]        :                                       
[ 173]        :                                       
[ 174]        :                                       ; A x B
[ 175]    0329: A1 05 02                              mov ax, A
[ 176]    032C: F7 2E 07 02                           imul B ; (dx ax) = ax * A.
[ 177]    0330: A3 67 02                              mov TEMP,ax
[ 178]        :                                       ; dx is ignored (calc works with tiny numbers only).
[ 179]        :                                       
[ 180]        :                                       ; + C
[ 181]    0333: A1 67 02                              mov ax, TEMP
[ 182]    0336: 03 06 09 02                           add ax, C
[ 183]    033A: A3 67 02                              mov TEMP,ax
[ 184]        :                                       
[ 185]        :                                       ; D x E
[ 186]    033D: A1 0B 02                              mov ax, D
[ 187]    0340: F7 2E 0D 02                           imul E
[ 188]    0344: A3 69 02                              mov TEMP2,ax
[ 189]    0347: 3D 00 00                              cmp ax, 0
[ 190]    034A: 74 1E                                 je undefined
[ 191]        :                                       
[ 192]        :                                       ; Y = (A x B + C)/(D x C)
[ 193]        :                                       ; dx is ignored (calc works with tiny integer numbers only).
[ 194]        :                                       
[ 195]    034C: A1 67 02                              mov     ax, TEMP
[ 196]    034F: 33 D2                                 xor     dx, dx
[ 197]        :                                       
[ 198]        :                                       ; check the sign, make dx:ax negative if ax is negative:
[ 199]    0351: 3D 00 00                              cmp     ax, 0
[ 200]    0354: 79 02                                 jns     not_signed
[ 201]    0356: F7 D2                                 not     dx
[ 202]    0358:                                       not_signed:
[ 203]    0358: 8B 1E 69 02                           mov     bx, TEMP2   ; divider is in bx.
[ 204]        :                                       
[ 205]        :                                       ; 'A' is in dx:ax.
[ 206]        :                                       ; 'B' is in bx.
[ 207]        :                                       
[ 208]    035C: F7 FB                                 idiv    bx      ; ax = dx:ax / bx       (dx - remainder).
[ 209]        :                                       
[ 210]        :                                       ; 'A/B' is in ax.
[ 211]        :                                       ; remainder is in dx.
[ 212]        :                                       
[ 213]    035E: 52                                    push    dx      ; store the remainder.
[ 214]        :                                       
[ 215]        :                                       
[ 216]    035F: 5A                                    pop     dx
[ 217]        :                                       
[ 218]        :                                       ; print 'A/B' as float:
[ 219]        :                                       ; ax - whole part
[ 220]        :                                       ; dx - remainder
[ 221]        :                                       ; bx - divider
[ 222]    0360: E8 DA 00                              call    print_float
[ 223]        :                                       
[ 224]    0363: EB 0C                                 jmp    exit
[ 225]        :                                       
[ 226]        :                                       
[ 227]    0365: E8 D5 00                              call print_float    ; print ax value.
[ 228]    0368: EB 07                                 jmp exit
[ 229]    036A:                                       undefined:
[ 230]        :                                       ; print "Undefined" if E is zero:
[ 231]    036A: BA 5D 02                              lea dx, sring_undefined
[ 232]    036D: B4 09                                 mov ah, 09h
[ 233]    036F: CD 21                                 int 21h
[ 234]        :                                       
[ 235]    0371:                                       exit:
[ 236]        :                                       ; output of a string at ds:dx
[ 237]    0371: BA ED 01                              lea dx, msg2
[ 238]    0374: B4 09                                 mov ah, 09h
[ 239]    0376: CD 21                                 int 21h
[ 240]        :                                       
[ 241]        :                                       ; wait for any key...
[ 242]    0378: B4 00                                 mov ah, 0
[ 243]    037A: CD 16                                 int 16h
[ 244]        :                                       
[ 245]    037C: C3                                    ret  ; return back to os.
[ 246]        :                                       
[ 247]        :                                       ;***************************************************************
[ 248]        :                                       ; gets the multi-digit SIGNED number from the keyboard,
[ 249]        :                                       ; and stores the result in CX register:
[ 250]    037D:                                       SCAN_NUM        PROC    NEAR
[ 251]    037D: 52                                    PUSH    DX
[ 252]    037E: 50                                    PUSH    AX
[ 253]    037F: 56                                    PUSH    SI
[ 254]        :                                       
[ 255]    0380: B9 00 00                              MOV     CX, 0
[ 256]        :                                       
[ 257]        :                                       ; reset flag:
[ 258]    0383: 2E C6 06 6F 02 00                     MOV     CS:make_minus, 0
[ 259]        :                                       
[ 260]    0389:                                       next_digit:
[ 261]        :                                       ; get char from keyboard
[ 262]        :                                       ; into AL:
[ 263]    0389: B4 00                                 MOV     AH, 00h
[ 264]    038B: CD 16                                 INT     16h
[ 265]        :                                       ; and print it:
[ 266]    038D: B4 0E                                 MOV     AH, 0Eh
[ 267]    038F: CD 10                                 INT     10h
[ 268]        :                                       
[ 269]        :                                       ; check for MINUS:
[ 270]    0391: 3C 2D                                 CMP     AL, '-'
[ 271]    0393: 74 69                                 JE      set_minus
[ 272]        :                                       
[ 273]        :                                       ; check for ENTER key:
[ 274]    0395: 3C 0D                                 CMP     AL, 0Dh  ; carriage return?
[ 275]    0397: 75 03                                 JNE     not_cr
[ 276]    0399: E9 93 00                              JMP     stop_input
[ 277]    039C:                                       not_cr:
[ 278]        :                                       
[ 279]        :                                       
[ 280]    039C: 3C 08                                 CMP     AL, 8                   ; 'BACKSPACE' pressed?
[ 281]    039E: 75 1E                                 JNE     backspace_checked
[ 282]    03A0: BA 00 00                              MOV     DX, 0                   ; remove last digit by
[ 283]    03A3: 8B C1                                 MOV     AX, CX                  ; division:
[ 284]    03A5: 2E F7 36 6B 02                        DIV     CS:ten                  ; AX = DX:AX / 10 (DX-rem).
[ 285]    03AA: 8B C8                                 MOV     CX, AX
[ 286]    03AC: 50 B0 20 B4 0E CD 10 58               PUTC    ' '                     ; clear position.
[ 287]    03B4: 50 B0 08 B4 0E CD 10 58               PUTC    8                       ; backspace again.
[ 288]    03BC: EB CB                                 JMP     next_digit
[ 289]    03BE:                                       backspace_checked:
[ 290]        :                                       ; allow only digits:
[ 291]    03BE: 3C 30                                 CMP     AL, '0'
[ 292]    03C0: 73 02                                 JAE     ok_AE_0
[ 293]    03C2: EB 04                                 JMP     remove_not_digit
[ 294]    03C4:                                       ok_AE_0:
[ 295]    03C4: 3C 39                                 CMP     AL, '9'
[ 296]    03C6: 76 1A                                 JBE     ok_digit
[ 297]    03C8:                                       remove_not_digit:
[ 298]    03C8: 50 B0 08 B4 0E CD 10 58               PUTC    8       ; backspace.
[ 299]    03D0: 50 B0 20 B4 0E CD 10 58               PUTC    ' '     ; clear last entered not digit.
[ 300]    03D8: 50 B0 08 B4 0E CD 10 58               PUTC    8       ; backspace again.
[ 301]    03E0: EB A7                                 JMP     next_digit ; wait for next input.
[ 302]    03E2:                                       ok_digit:
[ 303]        :                                       ; multiply CX by 10 (first time the result is zero)
[ 304]    03E2: 50                                    PUSH    AX
[ 305]    03E3: 8B C1                                 MOV     AX, CX
[ 306]    03E5: 2E F7 26 6B 02                        MUL     CS:ten                  ; DX:AX = AX*10
[ 307]    03EA: 8B C8                                 MOV     CX, AX
[ 308]    03EC: 58                                    POP     AX
[ 309]        :                                       
[ 310]        :                                       ; check if the number is too big
[ 311]        :                                       ; (result should be 16 bits)
[ 312]    03ED: 83 FA 00                              CMP     DX, 0
[ 313]    03F0: 75 19                                 JNE     too_big
[ 314]        :                                       
[ 315]        :                                       ; convert from ASCII code:
[ 316]    03F2: 2C 30                                 SUB     AL, 30h
[ 317]        :                                       
[ 318]        :                                       ; add AL to CX:
[ 319]    03F4: B4 00                                 MOV     AH, 0
[ 320]    03F6: 8B D1                                 MOV     DX, CX      ; backup, in case the result will be too big.
[ 321]    03F8: 03 C8                                 ADD     CX, AX
[ 322]    03FA: 72 0A                                 JC      too_big2    ; jump if the number is too big.
[ 323]        :                                       
[ 324]    03FC: EB 8B                                 JMP     next_digit
[ 325]        :                                       
[ 326]    03FE:                                       set_minus:
[ 327]    03FE: 2E C6 06 6F 02 01                     MOV     CS:make_minus, 1
[ 328]    0404: EB 83                                 JMP     next_digit
[ 329]        :                                       
[ 330]    0406:                                       too_big2:
[ 331]    0406: 8B CA                                 MOV     CX, DX      ; restore the backuped value before add.
[ 332]    0408: BA 00 00                              MOV     DX, 0       ; DX was zero before backup!
[ 333]    040B:                                       too_big:
[ 334]    040B: 8B C1                                 MOV     AX, CX
[ 335]    040D: 2E F7 36 6B 02                        DIV     CS:ten  ; reverse last DX:AX = AX*10, make AX = DX:AX / 10
[ 336]    0412: 8B C8                                 MOV     CX, AX
[ 337]    0414: 50 B0 08 B4 0E CD 10 58               PUTC    8       ; backspace.
[ 338]    041C: 50 B0 20 B4 0E CD 10 58               PUTC    ' '     ; clear last entered digit.
[ 339]    0424: 50 B0 08 B4 0E CD 10 58               PUTC    8       ; backspace again.
[ 340]    042C: E9 5A FF                              JMP     next_digit ; wait for Enter/Backspace.
[ 341]        :                                       
[ 342]        :                                       
[ 343]    042F:                                       stop_input:
[ 344]        :                                       ; check flag:
[ 345]    042F: 2E 80 3E 6F 02 00                     CMP     CS:make_minus, 0
[ 346]    0435: 74 02                                 JE      not_minus
[ 347]    0437: F7 D9                                 NEG     CX
[ 348]    0439:                                       not_minus:
[ 349]        :                                       
[ 350]    0439: 5E                                    POP     SI
[ 351]    043A: 58                                    POP     AX
[ 352]    043B: 5A                                    POP     DX
[ 353]    043C: C3                                    RET
[ 354]        :                                       SCAN_NUM        ENDP
[ 355]        :                                       
[ 356]        :                                       
[ 357]        :                                       
[ 358]        :                                       ;***************************************************************
[ 359]        :                                       ; prints number in ax and it's fraction in dx.
[ 360]        :                                       ; used to print remainder of 'div/idiv bx'.
[ 361]        :                                       ; ax - whole part.
[ 362]        :                                       ; dx - remainder.
[ 363]        :                                       ; bx - the divider that was used to get the remainder from divident.
[ 364]    043D:                                       print_float     proc    near
[ 365]    043D: 51                                    push    cx
[ 366]    043E: 52                                    push    dx
[ 367]        :                                       
[ 368]        :                                       ; because the remainder takes the sign of divident
[ 369]        :                                       ; its sign should be inverted when divider is negative
[ 370]        :                                       ; (-) / (-) = (+)
[ 371]        :                                       ; (+) / (-) = (-)
[ 372]    043F: 83 FB 00                              cmp     bx, 0
[ 373]    0442: 79 02                                 jns     div_not_signed
[ 374]    0444: F7 DA                                 neg     dx              ; make remainder positive.
[ 375]    0446:                                       div_not_signed:
[ 376]        :                                       ; print_num procedure does not print the '-'
[ 377]        :                                       ; when the whole part is '0' (even if the remainder is
[ 378]        :                                       ; negative) this code fixes it:
[ 379]    0446: 3D 00 00                              cmp     ax, 0
[ 380]    0449: 75 0C                                 jne     checked         ; ax<>0
[ 381]    044B: 83 FA 00                              cmp     dx, 0
[ 382]    044E: 79 07                                 jns     checked         ; ax=0 and dx>=0
[ 383]    0450: 52                                    push    dx
[ 384]    0451: B2 2D                                 mov     dl, '-'
[ 385]    0453: E8 B2 00                              call    write_char      ; print '-'
[ 386]    0456: 5A                                    pop     dx
[ 387]    0457:                                       checked:
[ 388]        :                                       ; print whole part:
[ 389]    0457: E8 49 00                              call    print_num
[ 390]        :                                       
[ 391]        :                                       ; if remainder=0, then no need to print it:
[ 392]    045A: 83 FA 00                              cmp     dx, 0
[ 393]    045D: 74 0D                                 je      done
[ 394]        :                                       
[ 395]    045F: 52                                    push    dx
[ 396]        :                                       ; print dot after the number:
[ 397]    0460: B2 2E                                 mov     dl, '.'
[ 398]    0462: E8 A3 00                              call    write_char
[ 399]    0465: 5A                                    pop     dx
[ 400]        :                                       
[ 401]        :                                       ; print digits after the dot:
[ 402]    0466: B9 1E 00                              mov     cx, precision
[ 403]    0469: E8 03 00                              call    print_fraction
[ 404]    046C:                                       done:
[ 405]    046C: 5A                                    pop     dx
[ 406]    046D: 59                                    pop     cx
[ 407]    046E: C3                                    ret
[ 408]        :                                       print_float     endp
[ 409]        :                                       
[ 410]        :                                       ;***************************************************************
[ 411]        :                                       ; prints dx as fraction of division by bx.
[ 412]        :                                       ; dx - remainder.
[ 413]        :                                       ; bx - divider.
[ 414]        :                                       ; cx - maximum number of digits after the dot.
[ 415]    046F:                                       print_fraction  proc    near
[ 416]    046F: 50                                    push    ax
[ 417]    0470: 52                                    push    dx
[ 418]    0471:                                       next_fraction:
[ 419]        :                                       ; check if all digits are already printed:
[ 420]    0471: 83 F9 00                              cmp     cx, 0
[ 421]    0474: 74 2A                                 jz      end_rem
[ 422]    0476: 49                                    dec     cx      ; decrease digit counter.
[ 423]        :                                       
[ 424]        :                                       ; when remainder is '0' no need to continue:
[ 425]    0477: 83 FA 00                              cmp     dx, 0
[ 426]    047A: 74 24                                 je      end_rem
[ 427]        :                                       
[ 428]    047C: 8B C2                                 mov     ax, dx
[ 429]    047E: 33 D2                                 xor     dx, dx
[ 430]    0480: 3D 00 00                              cmp     ax, 0
[ 431]    0483: 79 02                                 jns     not_sig1
[ 432]    0485: F7 D2                                 not     dx
[ 433]    0487:                                       not_sig1:
[ 434]    0487: F7 2E 6B 02                           imul    ten             ; dx:ax = ax * 10
[ 435]    048B: F7 FB                                 idiv    bx              ; ax = dx:ax / bx   (dx - remainder)
[ 436]    048D: 52                                    push    dx              ; store remainder.
[ 437]    048E: 8B D0                                 mov     dx, ax
[ 438]    0490: 83 FA 00                              cmp     dx, 0
[ 439]    0493: 79 02                                 jns     not_sig2
[ 440]    0495: F7 DA                                 neg     dx
[ 441]    0497:                                       not_sig2:
[ 442]    0497: 80 C2 30                              add     dl, 30h         ; convert to ascii code.
[ 443]    049A: E8 6B 00                              call    write_char      ; print dl.
[ 444]    049D: 5A                                    pop     dx
[ 445]        :                                       
[ 446]    049E: EB D1                                 jmp     next_fraction
[ 447]    04A0:                                       end_rem:
[ 448]    04A0: 5A                                    pop     dx
[ 449]    04A1: 58                                    pop     ax
[ 450]    04A2: C3                                    ret
[ 451]        :                                       print_fraction  endp
[ 452]        :                                       
[ 453]        :                                       ;***************************************************************
[ 454]        :                                       ; this procedure prints number in ax
[ 455]        :                                       ; used with print_numx to print "0" and sign.
[ 456]        :                                       ; this procedure also stores the original ax,
[ 457]        :                                       ; that is modified by print_numx.
[ 458]    04A3:                                       print_num       proc    near
[ 459]    04A3: 52                                    push    dx
[ 460]    04A4: 50                                    push    ax
[ 461]        :                                       
[ 462]    04A5: 3D 00 00                              cmp     ax, 0
[ 463]    04A8: 75 07                                 jnz     not_zero
[ 464]        :                                       
[ 465]    04AA: B2 30                                 mov     dl, '0'
[ 466]    04AC: E8 59 00                              call    write_char
[ 467]    04AF: EB 0F                                 jmp     printed
[ 468]        :                                       
[ 469]    04B1:                                       not_zero:
[ 470]        :                                       ; the check sign of ax,
[ 471]        :                                       ; make absolute if it's negative:
[ 472]    04B1: 3D 00 00                              cmp     ax, 0
[ 473]    04B4: 79 07                                 jns     positive
[ 474]    04B6: F7 D8                                 neg     ax
[ 475]        :                                       
[ 476]    04B8: B2 2D                                 mov     dl, '-'
[ 477]    04BA: E8 4B 00                              call    write_char
[ 478]    04BD:                                       positive:
[ 479]    04BD: E8 03 00                              call    print_numx
[ 480]    04C0:                                       printed:
[ 481]    04C0: 58                                    pop     ax
[ 482]    04C1: 5A                                    pop     dx
[ 483]    04C2: C3                                    ret
[ 484]        :                                       print_num       endp
[ 485]        :                                       
[ 486]        :                                       ;***************************************************************
[ 487]        :                                       ; prints out a number in ax (not just a single digit)
[ 488]        :                                       ; allowed values from 1 to 65535 (ffff)
[ 489]        :                                       ; (result of /10000 should be the left digit or "0").
[ 490]        :                                       ; modifies ax (after the procedure ax=0)
[ 491]    04C3:                                       print_numx      proc    near
[ 492]    04C3: 53                                    push    bx
[ 493]    04C4: 51                                    push    cx
[ 494]    04C5: 52                                    push    dx
[ 495]        :                                       ; flag to prevent printing zeros before number:
[ 496]    04C6: B9 01 00                              mov     cx, 1
[ 497]    04C9: BB 10 27                              mov     bx, 10000       ; 2710h - divider.
[ 498]        :                                       ; check if ax is zero, if zero go to end_show
[ 499]    04CC: 3D 00 00                              cmp     ax, 0
[ 500]    04CF: 74 2E                                 jz      end_show
[ 501]    04D1:                                       begin_print:
[ 502]        :                                       ; check divider (if zero go to end_show):
[ 503]    04D1: 83 FB 00                              cmp     bx,0
[ 504]    04D4: 74 29                                 jz      end_show
[ 505]        :                                       ; avoid printing zeros before number:
[ 506]    04D6: 83 F9 00                              cmp     cx, 0
[ 507]    04D9: 74 04                                 je      calc
[ 508]        :                                       ; if ax<bx then result of div will be zero:
[ 509]    04DB: 3B C3                                 cmp     ax, bx
[ 510]    04DD: 72 12                                 jb      skip
[ 511]    04DF:                                       calc:
[ 512]    04DF: 33 C9                                 xor     cx, cx  ; set flag.
[ 513]    04E1: 33 D2                                 xor     dx, dx
[ 514]    04E3: F7 F3                                 div     bx      ; ax = dx:ax / bx   (dx=remainder).
[ 515]        :                                       ; print last digit
[ 516]        :                                       ; ah is always zero, so it's ignored
[ 517]    04E5: 52                                    push    dx
[ 518]    04E6: 8A D0                                 mov     dl, al
[ 519]    04E8: 80 C2 30                              add     dl, 30h    ; convert to ascii code.
[ 520]    04EB: E8 1A 00                              call    write_char
[ 521]    04EE: 5A                                    pop     dx
[ 522]    04EF: 8B C2                                 mov     ax, dx  ; get remainder from last div.
[ 523]    04F1:                                       skip:
[ 524]        :                                       ; calculate bx=bx/10
[ 525]    04F1: 50                                    push    ax
[ 526]    04F2: 33 D2                                 xor     dx, dx
[ 527]    04F4: 8B C3                                 mov     ax, bx
[ 528]    04F6: F7 36 6B 02                           div     ten     ; ax = dx:ax / 10   (dx=remainder).
[ 529]    04FA: 8B D8                                 mov     bx, ax
[ 530]    04FC: 58                                    pop     ax
[ 531]    04FD: EB D2                                 jmp     begin_print
[ 532]    04FF:                                       end_show:
[ 533]    04FF: 5A                                    pop     dx
[ 534]    0500: 59                                    pop     cx
[ 535]    0501: 5B                                    pop     bx
[ 536]    0502: C3                                    ret
[ 537]        :                                       print_numx      endp
[ 538]        :                                       ;***************************************************************
[ 539]        :                                       ; reads char from the keyboard into al
[ 540]        :                                       ; (modifies ax!!!)
[ 541]    0503:                                       read_char       proc    near
[ 542]    0503: B4 01                                 mov     ah, 01h
[ 543]    0505: CD 21                                 int     21h
[ 544]    0507: C3                                    ret
[ 545]        :                                       read_char       endp
[ 546]        :                                       ;***************************************************************
[ 547]        :                                       ; prints out single char (ascii code should be in dl)
[ 548]    0508:                                       write_char      proc    near
[ 549]    0508: 50                                    push    ax
[ 550]    0509: B4 02                                 mov     ah, 02h
[ 551]    050B: CD 21                                 int     21h
[ 552]    050D: 58                                    pop     ax
[ 553]    050E: C3                                    ret
[ 554]        :                                       write_char      endp
[ 555]        :                                       ;***************************************************************
[ 556]        :                                       
 
===================================================================================================
 
